from standard_graph import StandardGraph, linear_graph
import os
import subprocess

def check_KaLP_dimacs_format(path: str):
    nr_vertices = None
    nr_edges = None
    edges = []
    with open(path, "r") as f:
        for i, line in enumerate(f):
            l = line.split(" ")

            if len(l) != 4: return f"Wrong format at line {i + 1}"

            if i == 0:
                if l[0] != 'p': return f"First line does not start with 'p'."
                if l[1] != 'sp': return f"First line does not include 'sp'."
                nr_vertices = int(l[2])
                nr_edges = int(l[3])
            else:
                if l[0] != 'a': return f"Line {i + 1} does not start with 'a'"
                if l[3].strip() != '1': return f"Line {i + 1} does not end with '1'"
                edges.append((int(l[1]), int(l[2])))

    if len(edges) != nr_edges: return f"Number of edges is incorrect: {nr_edges} claimed but there are {len(edges)}."

    vertices = set([v for (v, _) in edges] + [v for (_, v) in edges])

    if min(vertices) <= 0: return f"Vertices must be greater than or equal to 1."
    if max(vertices) > nr_vertices: return f"Number of vertices is incorrect: {nr_vertices} claimed but there is a vertex of number '{max(vertices)}'"

    undirected = {frozenset([s, t]) for s, t in edges}
    undirected_list = [tuple(e) for e in undirected]
    undirected_directed_list = undirected_list + [(t, s) for (s, t) in undirected_list]

    edges.sort()
    undirected_directed_list.sort()

    if edges != undirected_directed_list: return "Graph format incorrect. NOTE: The graph should contain all back edges."

    return "Correct", StandardGraph(nr_vertices, [(s - 1, t - 1) for (s, t) in edges])

def export_KaLP_dimacs(path: str, graph: StandardGraph):
    """
    Writes a graph to a dimacs file in a format that KaLP will accept.
    WARNING: KaLP wants vertices to be >= 1 so all vertices are shifted over by +1 in the output file. Note that the kalp command wants start and target vertex starting from 0 so KaLP subtracts 1 again.
    WARNING: KaLP only accepts undirected graphs. Hence this function turns the graph into an undirected one by adding all back edges. Moreover, all selfloops are removed.
    """

    undirected = {frozenset([s, t]) for s, t in graph.edges}
    undirected_list = [tuple(e) for e in undirected if len(e) > 1]
    undirected_directed_list = undirected_list + [(t, s) for (s, t) in undirected_list]

    with open(path, "w") as f:
        f.write(f"p sp {graph.vertices} {len(undirected_directed_list)}\n")

        for s, t in undirected_directed_list:
            f.write(f"a {s + 1} {t + 1} 1\n")

def export_KaLP_dimacs_with_universal_nodes(path: str, graph: StandardGraph):
    graph = graph.clone()
    graph.add_universal_nodes()
    export_KaLP_dimacs(path, graph)


def run_KaLP_with_start_and_target(
        path: str, 
        start, 
        target,
        threads=None,
        steps=None,
        partition_configuration=None,
        kalp_path=os.environ['KALP_PATH']
    ):
    """
    Runs KaLP on the file specified by `path`. 
    NOTE: Uses the environment variable KALP_PATH by default if the argument kalp_path is not provided.
    """
    command = [
        kalp_path, 
        path, 
        f'--start_vertex={start}', 
        f'--target_vertex={target}', 
        '--print_path'
    ]

    if threads != None:
        command.append(f"--threads={threads}")
    if steps != None:
        command.append(f"--steps={steps}")
    if partition_configuration != None:
        command.append(f"--partition_configuration={partition_configuration}")

    result = subprocess.run(
        command, 
        stdout=subprocess.PIPE, 
        text=True
    )
    lines = result.stdout.splitlines()

    path = []

    while len(lines) > 0:
        line = lines.pop()
        if line.strip().isdigit():
            path.append(int(line))
        else:
            break

    return path, result.stdout

def run_KaLP_universal(path: str, *args, **kwargs):
    """
    Runs KaLP using `run_KaLP_with_start_and_target` to find the longest path in a graph specified by `path`.
    This is inteded to be used on files generated by `export_KaLP_dimacs_with_universal_nodes`.
    """
    nr_vertices = None

    with open(path, 'r') as f:
        nr_vertices = int(f.readline().split(" ")[2])

    path, stdout = run_KaLP_with_start_and_target(path, nr_vertices - 2, nr_vertices - 1, *args, **kwargs)

    if len(path) > 2:
        return path[1:-1], stdout
    else:
        return [], stdout

if __name__ == "__main__":
    export_KaLP_dimacs_with_universal_nodes("test.dimacs", linear_graph(5))
    print(check_KaLP_dimacs_format("test.dimacs"))
    print(os.environ['KALP_PATH'])
    print(run_KaLP_universal("test.dimacs")[0])
